{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Civic Interconnect Project Documentation","text":"<p>Welcome to the documentation for Civic Interconnect (CI) projects.</p> <p>Use the navigation menu to explore available modules, APIs, and tools.</p> <p>For more information, visit the Civic Interconnect GitHub organization.</p>"},{"location":"api/bump_version/","title":"Module <code>bump_version</code>","text":""},{"location":"api/bump_version/#classes","title":"Classes","text":""},{"location":"api/bump_version/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/bump_version/#functions","title":"Functions","text":""},{"location":"api/bump_version/#bump_version_cmdold_version-str-new_version-str-int","title":"<code>bump_version_cmd(old_version: str, new_version: str) -&gt; int</code>","text":"<p>CLI subcommand handler for version bump.</p> <p>Returns:     int: Exit code (0 on success, 1 if no updates).</p>"},{"location":"api/bump_version/#mainold_version-str-new_version-str-int","title":"<code>main(old_version: str, new_version: str) -&gt; int</code>","text":"<p>Script-style entry point.</p> <p>Returns:     int: Exit code.</p>"},{"location":"api/bump_version/#update_filepath-pathlibpath-old-str-new-str-bool","title":"<code>update_file(path: pathlib.Path, old: str, new: str) -&gt; bool</code>","text":"<p>Replace version string in the specified file if found.</p> <p>Returns:     bool: True if file was modified, False otherwise.</p>"},{"location":"api/cli.cli/","title":"Module <code>cli.cli</code>","text":""},{"location":"api/cli.cli/#functions","title":"Functions","text":""},{"location":"api/cli.cli/#hello","title":"<code>hello()</code>","text":"<p>Basic test command.</p>"},{"location":"api/cli/","title":"Module <code>cli</code>","text":""},{"location":"api/cli/#functions","title":"Functions","text":""},{"location":"api/cli/#bump_version_commandold_version-str-new_version-str","title":"<code>bump_version_command(old_version: str, new_version: str)</code>","text":"<p>Update version strings across the project.</p>"},{"location":"api/cli/#install_deps_commandis_editable-bool-typermodelsoptioninfo-object-at-0x00000238f61e8c80","title":"<code>install_deps_command(is_editable: bool = &lt;typer.models.OptionInfo object at 0x00000238F61E8C80&gt;)</code>","text":"<p>Install project dependencies into the existing virtual environment.</p>"},{"location":"api/cli/#layout_command","title":"<code>layout_command()</code>","text":"<p>Show the current project layout.</p>"},{"location":"api/cli/#main","title":"<code>main()</code>","text":"<p>No description available.</p>"},{"location":"api/cli/#prepare_code","title":"<code>prepare_code()</code>","text":"<p>Format, lint, and test the codebase.</p>"},{"location":"api/cli/#publish_api_command","title":"<code>publish_api_command()</code>","text":"<p>Fetch or regenerate app API files.</p>"},{"location":"api/cli/#release_command","title":"<code>release_command()</code>","text":"<p>Tag and push the current version to GitHub.</p>"},{"location":"api/config_utils/","title":"Module <code>config_utils</code>","text":""},{"location":"api/config_utils/#classes","title":"Classes","text":""},{"location":"api/config_utils/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/config_utils/#functions","title":"Functions","text":""},{"location":"api/config_utils/#load_api_keyenv_var-str-service_name-str-str","title":"<code>load_api_key(env_var: str, service_name: str) -&gt; str</code>","text":"<p>Load an API key from the environment variables.</p> <p>Args:     env_var (str): The name of the environment variable to read.     service_name (str): A friendly name for the service (for error messages).</p> <p>Returns:     str: The API key value.</p> <p>Exits:     If the environment variable is missing or empty.</p>"},{"location":"api/config_utils/#load_versionfilename-str-version-root_dir-pathlibpath-none-none-str","title":"<code>load_version(filename: str = 'VERSION', root_dir: pathlib.Path | None = None) -&gt; str</code>","text":"<p>Load the version string from a VERSION file in the project.</p> <p>Args:     filename (str): Name of the version file (default: \"VERSION\").     root_dir (Optional[Path]): Base path to search (default: detected project root).</p> <p>Returns:     str: Version string (e.g., \"1.2.3\").</p> <p>Exits:     If the version file is missing or unreadable.</p>"},{"location":"api/config_utils/#load_yaml_configfilename-str-configyaml-root_dir-pathlibpath-none-none-dict","title":"<code>load_yaml_config(filename: str = 'config.yaml', root_dir: pathlib.Path | None = None) -&gt; dict</code>","text":"<p>Load a YAML configuration file from the project root.</p> <p>Args:     filename (str): Name of the config file (default: \"config.yaml\").     root_dir (Optional[Path]): Directory to search (default: detected project root).</p> <p>Returns:     dict: Parsed configuration as a Python dictionary.</p> <p>Raises:     FileNotFoundError: If the config file cannot be found.</p>"},{"location":"api/config_utils/#parse_versionversion-str-tupleint-int-int","title":"<code>parse_version(version: str) -&gt; tuple[int, int, int]</code>","text":"<p>Parse a version string (e.g., \"1.2.3\") into a tuple of integers.</p> <p>Args:     version (str): Version string.</p> <p>Returns:     tuple[int, int, int]: A tuple of (major, minor, patch).</p> <p>Raises:     ValueError: If the version string is improperly formatted.</p>"},{"location":"api/date_utils/","title":"Module <code>date_utils</code>","text":""},{"location":"api/date_utils/#classes","title":"Classes","text":""},{"location":"api/date_utils/#datetimeself-args-kwargs","title":"<code>datetime(self, /, *args, **kwargs)</code>","text":"<p>datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])</p> <p>The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints.</p>"},{"location":"api/date_utils/#timedeltaself-args-kwargs","title":"<code>timedelta(self, /, *args, **kwargs)</code>","text":"<p>Difference between two datetime values.</p> <p>timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)</p> <p>All arguments are optional and default to 0. Arguments may be integers or floats, and may be positive or negative.</p>"},{"location":"api/date_utils/#functions","title":"Functions","text":""},{"location":"api/date_utils/#date_rangedays_back-int-liststr","title":"<code>date_range(days_back: int) -&gt; list[str]</code>","text":"<p>Generate a list of date strings from <code>days_back</code> days ago up to today (UTC).</p> <p>Args:     days_back (int): Number of days to include, ending with today (inclusive).</p> <p>Returns:     list[str]: List of UTC dates in 'YYYY-MM-DD' format, earliest to latest.</p> <p>Raises:     ValueError: If days_back is negative.</p>"},{"location":"api/date_utils/#now_utc-datetimedatetime","title":"<code>now_utc() -&gt; datetime.datetime</code>","text":"<p>Return the current UTC datetime object.</p> <p>Returns:     datetime: Current UTC datetime.</p>"},{"location":"api/date_utils/#now_utc_strfmt-str-y-m-d-hms-utc-str","title":"<code>now_utc_str(fmt: str = '%Y-%m-%d %H:%M:%S UTC') -&gt; str</code>","text":"<p>Return the current time in UTC as a formatted string.</p> <p>Args:     fmt (str): Format string for datetime output. Default includes 'UTC'.</p> <p>Returns:     str: Formatted current UTC time.</p>"},{"location":"api/date_utils/#today_utc_str-str","title":"<code>today_utc_str() -&gt; str</code>","text":"<p>Return today's date in UTC in 'YYYY-MM-DD' format.</p> <p>Returns:     str: Current UTC date as a string.</p>"},{"location":"api/dev_utils/","title":"Module <code>dev_utils</code>","text":""},{"location":"api/dev_utils/#functions","title":"Functions","text":""},{"location":"api/dev_utils/#log_suggested_pathsresponse-dict-max_depth-int-3-source_label-str-response-none","title":"<code>log_suggested_paths(response: dict, max_depth: int = 3, source_label: str = 'response') -&gt; None</code>","text":"<p>Log inferred paths to nested keys in a response dictionary.</p> <p>Args:     response (dict): Parsed API response.     max_depth (int): Maximum depth to explore.     source_label (str): Label for context in logs.</p>"},{"location":"api/dev_utils/#suggest_pathsresponse-dict-max_depth-int-3-current_path-liststr-none-none-listtupleliststr-str-str","title":"<code>suggest_paths(response: dict, max_depth: int = 3, current_path: list[str] | None = None) -&gt; list[tuple[list[str], str, str]]</code>","text":"<p>Suggest possible nested data paths in a response dictionary.</p> <p>Args:     response (dict): Parsed API response.     max_depth (int): Maximum traversal depth.     current_path (list[str] | None): Used internally for recursion.</p> <p>Returns:     list of (path, key, summary): Potential paths to explore.</p>"},{"location":"api/docs_api_build/","title":"Module <code>docs_api_build</code>","text":""},{"location":"api/docs_api_build/#classes","title":"Classes","text":""},{"location":"api/docs_api_build/#anyself-args-kwargs","title":"<code>Any(self, /, *args, **kwargs)</code>","text":"<p>Special type indicating an unconstrained type.</p> <ul> <li>Any is compatible with every type.</li> <li>Any assumed to have all methods.</li> <li>All values assumed to be instances of Any.</li> </ul> <p>Note that all the above statements are true from the point of view of static type checkers. At runtime, Any should not be used with instance checks.</p>"},{"location":"api/docs_api_build/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/docs_api_build/#functions","title":"Functions","text":""},{"location":"api/docs_api_build/#generate_api_docssource_pkg_path-pathlibpath-project_root-pathlibpath-policy-dictstr-typingany-none","title":"<code>generate_api_docs(source_pkg_path: pathlib.Path, project_root: pathlib.Path, policy: dict[str, typing.Any]) -&gt; None</code>","text":"<p>Generate Markdown API documentation for a single package.</p> <p>Writes output into mkdocs_src/api. This function is a wrapper for docs_api_config.generate_docs, ensuring 'markdown' format by default.</p> <p>Args:     source_pkg_path (Path): The absolute path to the Python package directory to document.     project_root (Path): The root directory of the project.     policy (Dict[str, Any]): The loaded project policy.</p>"},{"location":"api/docs_api_build/#publish_api_docs-none","title":"<code>publish_api_docs() -&gt; None</code>","text":"<p>One-liner to generate complete API documentation for release.</p> <ul> <li>Discovers all Python packages in src/.</li> <li>Generates Markdown &amp; YAML docs for each into mkdocs_src/api.</li> <li>Writes mkdocs.yml to repo root.</li> <li>Writes index.md to mkdocs_src.</li> </ul>"},{"location":"api/docs_api_config/","title":"Module <code>docs_api_config</code>","text":""},{"location":"api/docs_api_config/#classes","title":"Classes","text":""},{"location":"api/docs_api_config/#anyself-args-kwargs","title":"<code>Any(self, /, *args, **kwargs)</code>","text":"<p>Special type indicating an unconstrained type.</p> <ul> <li>Any is compatible with every type.</li> <li>Any assumed to have all methods.</li> <li>All values assumed to be instances of Any.</li> </ul> <p>Note that all the above statements are true from the point of view of static type checkers. At runtime, Any should not be used with instance checks.</p>"},{"location":"api/docs_api_config/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/docs_api_config/#functions","title":"Functions","text":""},{"location":"api/docs_api_config/#build_api_navapi_src_dir-pathlibpath-mkdocs_base_src_dir-pathlibpath-listdictstr-str","title":"<code>build_api_nav(api_src_dir: pathlib.Path, mkdocs_base_src_dir: pathlib.Path) -&gt; list[dict[str, str]]</code>","text":"<p>Scan api_src_dir (e.g., mkdocs_src/api) for .md files and build a flat MkDocs nav entry for each.</p> <p>Args:     api_src_dir (Path): The directory containing API Markdown files (e.g., mkdocs_src/api).     mkdocs_base_src_dir (Path): The base MkDocs source directory (e.g., mkdocs_src).</p> <p>Returns:     list[dict[str, str]]: nav entries for mkdocs.yml</p>"},{"location":"api/docs_api_config/#ensure_dirpath-str-pathlibpath-pathlibpath","title":"<code>ensure_dir(path: str | pathlib.Path) -&gt; pathlib.Path</code>","text":"<p>Ensure a directory exists, creating it if necessary.</p> <p>Args:     path (str | Path): The directory path to ensure.</p> <p>Returns:     Path: The resolved Path object of the directory.</p> <p>Raises:     OSError: If directory cannot be created.</p>"},{"location":"api/docs_api_config/#extract_module_apipackage_path-pathlibpath-dictstr-dict","title":"<code>extract_module_api(package_path: pathlib.Path) -&gt; dict[str, dict]</code>","text":"<p>Recursively extract public functions and classes from Python source files.</p> <p>Args:     package_path (Path): Path to a Python package directory.</p> <p>Returns:     dict[str, dict]: Mapping of module names to their functions and classes.</p>"},{"location":"api/docs_api_config/#generate_docssource_pkg_path-pathlibpath-project_root-pathlibpath-policy-dictstr-typingany-formats-str-liststr-none-none-none","title":"<code>generate_docs(source_pkg_path: pathlib.Path, project_root: pathlib.Path, policy: dict[str, typing.Any], formats: str | list[str] | None = None) -&gt; None</code>","text":"<p>Generate API documentation in multiple formats for a given source package.</p> <p>Writes files into the determined API Markdown source directory (e.g., mkdocs_src/api/).</p> <p>Args:     source_pkg_path (Path): The absolute path to the Python package directory to document.     project_root (Path): The root directory of the project.     policy (dict[str, Any]): The loaded project policy.     formats (str | list[str] | None): Output formats (e.g., \"yaml\", \"markdown\").</p>"},{"location":"api/docs_api_config/#generate_mkdocs_configproject_name-str-root_dir-pathlibpath-policy-dictstr-typingany-include_api_nav-bool-true-custom_nav-listdictstr-typingany-none-none-mkdocs_base_src_dir-pathlibpath-none-none-api_markdown_src_dir-pathlibpath-none-none-none","title":"<code>generate_mkdocs_config(project_name: str, root_dir: pathlib.Path, policy: dict[str, typing.Any], include_api_nav: bool = True, custom_nav: list[dict[str, typing.Any]] | None = None, mkdocs_base_src_dir: pathlib.Path | None = None, api_markdown_src_dir: pathlib.Path | None = None) -&gt; None</code>","text":"<p>Generate mkdocs.yml configuration file.</p> <p>Args:     project_name (str): The name of the project.     root_dir (Path): The repo root.     policy (dict[str, Any]): The loaded project policy.     include_api_nav (bool): Whether to scan for API docs.     custom_nav (list[dict[str, Any]] | None): Additional nav entries.     mkdocs_base_src_dir (Path | None): The base directory for MkDocs source files (e.g., mkdocs_src).                                          If None, it will be derived from policy.     api_markdown_src_dir (Path | None): The directory where API markdown files are generated.                                            If None, it will be derived from policy.</p>"},{"location":"api/docs_api_config/#generate_summary_yamlsource_pkg_path-pathlibpath-project_root-pathlibpath-policy-dictstr-typingany-none","title":"<code>generate_summary_yaml(source_pkg_path: pathlib.Path, project_root: pathlib.Path, policy: dict[str, typing.Any]) -&gt; None</code>","text":"<p>Generate YAML API summary (backward compatibility).</p>"},{"location":"api/docs_api_config/#get_api_markdown_source_dirpolicy-dict-none-none-root_dir-pathlibpath-none-none-pathlibpath","title":"<code>get_api_markdown_source_dir(policy: dict | None = None, root_dir: pathlib.Path | None = None) -&gt; pathlib.Path</code>","text":"<p>Determines the specific directory within mkdocs_src where API Markdown files should go. This is the target for the Python script generating API Markdown.</p> <p>Args:     policy (Optional[dict]): The loaded project policy. If None, it will be loaded internally.     root_dir (Optional[Path]): The project root directory. If None, it will be discovered internally.</p> <p>Returns:     Path: The absolute path to the API Markdown source directory (e.g., project_root/mkdocs_src/api).</p>"},{"location":"api/docs_api_config/#get_mkdocs_pathspolicy-dict-project_root-pathlibpath-tuplepathlibpath-pathlibpath","title":"<code>get_mkdocs_paths(policy: dict, project_root: pathlib.Path) -&gt; tuple[pathlib.Path, pathlib.Path]</code>","text":"<p>Return paths to mkdocs.yml and the mkdocs source folder based on policy.</p> <p>Args:     policy (dict): Loaded project policy.     project_root (Path): Root of the repo.</p> <p>Returns:     Tuple[Path, Path]: (mkdocs_config_file_path, mkdocs_src_path)</p>"},{"location":"api/docs_api_config/#normalize_formatsformats-str-liststr-none-liststr","title":"<code>normalize_formats(formats: str | list[str] | None) -&gt; list[str]</code>","text":"<p>Ensure formats is a list of strings.</p>"},{"location":"api/docs_api_config/#write_index_mddocs_src_dir-pathlibpath-none","title":"<code>write_index_md(docs_src_dir: pathlib.Path) -&gt; None</code>","text":"<p>Write the index.md file to mkdocs_src/.</p> <p>Args:     docs_src_dir (Path): The mkdocs source directory.</p>"},{"location":"api/docs_api_config/#write_markdown_docsapi_data-dict-output_dir-pathlibpath-none","title":"<code>write_markdown_docs(api_data: dict, output_dir: pathlib.Path) -&gt; None</code>","text":"<p>Write full Markdown documentation for all extracted modules.</p> <p>Args:     api_data (dict): Dictionary from extract_module_api.     output_dir (Path): Path to folder where Markdown files will be written.</p>"},{"location":"api/docs_api_config/#write_yaml_summaryapi_data-dict-output_dir-pathlibpath-none","title":"<code>write_yaml_summary(api_data: dict, output_dir: pathlib.Path) -&gt; None</code>","text":"<p>Write a minimal YAML summary listing module names and their function names.</p> <p>Args:     api_data (dict): Dictionary from extract_module_api.     output_dir (Path): Path to folder where API.yaml will be written.</p>"},{"location":"api/docs_api_extract/","title":"Module <code>docs_api_extract</code>","text":""},{"location":"api/docs_api_extract/#classes","title":"Classes","text":""},{"location":"api/docs_api_extract/#moduletypeself-args-kwargs","title":"<code>ModuleType(self, /, *args, **kwargs)</code>","text":"<p>Create a module object.</p> <p>The name must be a string; the optional doc argument can have any type.</p>"},{"location":"api/docs_api_extract/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/docs_api_extract/#functions","title":"Functions","text":""},{"location":"api/docs_api_extract/#dynamic_import_from_pathfile_path-pathlibpath-module_name-str-module","title":"<code>dynamic_import_from_path(file_path: pathlib.Path, module_name: str) -&gt; module</code>","text":"<p>Dynamically import a Python module from a file path.</p> <p>Args:     file_path (Path): Path to the .py file.     module_name (str): Name to assign to the imported module.</p> <p>Returns:     ModuleType: Imported Python module object.</p> <p>Raises:     ImportError: If module cannot be loaded.</p>"},{"location":"api/docs_api_extract/#extract_module_apipackage_path-pathlibpath-dictstr-dict","title":"<code>extract_module_api(package_path: pathlib.Path) -&gt; dict[str, dict]</code>","text":"<p>Recursively extract public functions and classes from Python source files.</p> <p>Args:     package_path (Path): Path to a Python package directory.</p> <p>Returns:     dict[str, dict]: Mapping of module names to their functions and classes.</p>"},{"location":"api/docs_api_extract/#extract_public_namestree-astast-setstr","title":"<code>extract_public_names(tree: ast.AST) -&gt; set[str]</code>","text":"<p>Extract names listed in a module's all variable.</p> <p>Args:     tree (ast.AST): Parsed AST tree.</p> <p>Returns:     set[str]: Public names listed in all, if any.</p>"},{"location":"api/docs_api_extract/#find_public_classestree-astast-public_names-setstr-listdictstr-str","title":"<code>find_public_classes(tree: ast.AST, public_names: set[str]) -&gt; list[dict[str, str]]</code>","text":"<p>Find all public classes in a Python module AST.</p> <p>Args:     tree (ast.AST): Parsed AST tree.     public_names (set[str]): Names explicitly marked public in all.</p> <p>Returns:     list[dict[str, str]]: Class info dicts.</p>"},{"location":"api/docs_api_extract/#find_public_functionstree-astast-public_names-setstr-listdictstr-str","title":"<code>find_public_functions(tree: ast.AST, public_names: set[str]) -&gt; list[dict[str, str]]</code>","text":"<p>Find all public functions in a Python module AST.</p> <p>Args:     tree (ast.AST): Parsed AST tree.     public_names (set[str]): Names explicitly marked public in all.</p> <p>Returns:     list[dict[str, str]]: Function info dicts.</p>"},{"location":"api/docs_api_extract/#get_public_membersmodule-tuplelistdictstr-str-listdictstr-str","title":"<code>get_public_members(module) -&gt; tuple[list[dict[str, str]], list[dict[str, str]]]</code>","text":"<p>Inspect a live imported Python module for public classes and functions.</p> <p>Args:     module (ModuleType): Imported Python module.</p> <p>Returns:     tuple: (functions, classes)         Each is a list of dicts with name, signature, and docstring.</p>"},{"location":"api/docs_api_extract/#parse_python_filefile_path-pathlibpath-astast-none","title":"<code>parse_python_file(file_path: pathlib.Path) -&gt; ast.AST | None</code>","text":"<p>Parse a Python file into an AST.</p> <p>Args:     file_path (Path): Path to a Python file.</p> <p>Returns:     ast.AST | None: AST object if parsing succeeds, else None.</p>"},{"location":"api/docs_api_render/","title":"Module <code>docs_api_render</code>","text":""},{"location":"api/docs_api_render/#classes","title":"Classes","text":""},{"location":"api/docs_api_render/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/docs_api_render/#functions","title":"Functions","text":""},{"location":"api/docs_api_render/#write_markdown_docsapi_data-dict-output_dir-pathlibpath-none","title":"<code>write_markdown_docs(api_data: dict, output_dir: pathlib.Path) -&gt; None</code>","text":"<p>Write full Markdown documentation for all extracted modules.</p> <p>Args:     api_data (dict): Dictionary from extract_module_api.     output_dir (Path): Path to folder where Markdown files will be written.</p>"},{"location":"api/docs_api_render/#write_module_markdownfile_path-pathlibpath-module_name-str-functions-listdictstr-str-classes-listdictstr-str-none","title":"<code>write_module_markdown(file_path: pathlib.Path, module_name: str, functions: list[dict[str, str]], classes: list[dict[str, str]]) -&gt; None</code>","text":"<p>Write Markdown documentation for a single Python module.</p> <p>Args:     file_path (Path): Output file path.     module_name (str): Name of the module being documented.     functions (list[dict]): Public functions extracted from the module.     classes (list[dict]): Public classes extracted from the module.</p>"},{"location":"api/docs_api_render/#write_yaml_summaryapi_data-dict-output_dir-pathlibpath-none","title":"<code>write_yaml_summary(api_data: dict, output_dir: pathlib.Path) -&gt; None</code>","text":"<p>Write a minimal YAML summary listing module names and their function names.</p> <p>Args:     api_data (dict): Dictionary from extract_module_api.     output_dir (Path): Path to folder where API.yaml will be written.</p>"},{"location":"api/fs_utils/","title":"Module <code>fs_utils</code>","text":""},{"location":"api/fs_utils/#classes","title":"Classes","text":""},{"location":"api/fs_utils/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/fs_utils/#projectlayoutself-args-kwargs","title":"<code>ProjectLayout(self, /, *args, **kwargs)</code>","text":"<p>Represents the layout of a project, including key directories and metadata.</p> <p>Attributes:     project_root (Path): The root directory of the project.     src_dir (Path | None): The source directory containing the main code, or None if not applicable.     packages (list[Path]): A list of paths to package directories within the project.     api_markdown_src_dir (Path): The directory containing API documentation source Markdown files                                   (e.g., project_root/mkdocs_src/api).     org_name (str | None): The name of the organization, or None if not specified.     policy (dict): A dictionary containing project policy information.</p>"},{"location":"api/fs_utils/#functions","title":"Functions","text":""},{"location":"api/fs_utils/#discover_project_layout-civic_lib_coreproject_layoutprojectlayout","title":"<code>discover_project_layout() -&gt; civic_lib_core.project_layout.ProjectLayout</code>","text":"<p>Dynamically discovers and returns key layout paths and information for the current Civic Interconnect project, encapsulated in a ProjectLayout NamedTuple.</p> <p>This function performs the following steps: 1. Determines the project root directory. 2. Loads the project policy configuration. 3. Identifies the primary source directory (e.g., 'src/'). 4. Lists all top-level Python packages within the source directory. 5. Calculates the path to the API documentation source directory (mkdocs_src/api). 6. Attempts to determine the organization name associated with the project.</p> <p>The returned ProjectLayout object provides structured, type-hinted access to these essential project paths and configurations, simplifying their consumption by other parts of the system and improving type safety.</p> <p>Returns:     ProjectLayout: A NamedTuple containing structured layout information,                     including project_root, src_dir, packages, docs_api_dir,                     org_name, and the loaded policy.</p>"},{"location":"api/fs_utils/#ensure_dirpath-str-pathlibpath-pathlibpath","title":"<code>ensure_dir(path: str | pathlib.Path) -&gt; pathlib.Path</code>","text":"<p>Ensure a directory exists, creating it if necessary.</p> <p>Args:     path (str | Path): The directory path to ensure.</p> <p>Returns:     Path: The resolved Path object of the directory.</p> <p>Raises:     OSError: If directory cannot be created.</p>"},{"location":"api/fs_utils/#ensure_docs_output_dirproject_root-pathlibpath-none-none-policy-dict-none-none-pathlibpath","title":"<code>ensure_docs_output_dir(project_root: pathlib.Path | None = None, policy: dict | None = None) -&gt; pathlib.Path</code>","text":"<p>Ensures the final HTML output directory for MkDocs exists. This is typically <code>project_root/docs/</code>, as defined in the project policy.</p> <p>Args:     project_root (Optional[Path]): The project root directory. If None, it will be discovered internally.     policy (Optional[dict]): The loaded project policy. If None, it will be loaded internally.</p> <p>Returns:     Path: The created or existing path to the main HTML output directory.</p> <p>Raises:     Exception: If the directory cannot be located or created.</p>"},{"location":"api/fs_utils/#find_project_rootstart_path-pathlibpath-none-none-pathlibpath","title":"<code>find_project_root(start_path: pathlib.Path | None = None) -&gt; pathlib.Path</code>","text":"<p>DEPRECATED: Use get_project_root instead.</p>"},{"location":"api/fs_utils/#find_source_dirroot_dir-pathlibpath-pathlibpath-none","title":"<code>find_source_dir(root_dir: pathlib.Path) -&gt; pathlib.Path | None</code>","text":"<p>DEPRECATED: Use get_source_dir instead.</p>"},{"location":"api/fs_utils/#get_api_markdown_source_dirpolicy-dict-none-none-root_dir-pathlibpath-none-none-pathlibpath","title":"<code>get_api_markdown_source_dir(policy: dict | None = None, root_dir: pathlib.Path | None = None) -&gt; pathlib.Path</code>","text":"<p>Determines the specific directory within mkdocs_src where API Markdown files should go. This is the target for the Python script generating API Markdown.</p> <p>Args:     policy (Optional[dict]): The loaded project policy. If None, it will be loaded internally.     root_dir (Optional[Path]): The project root directory. If None, it will be discovered internally.</p> <p>Returns:     Path: The absolute path to the API Markdown source directory (e.g., project_root/mkdocs_src/api).</p>"},{"location":"api/fs_utils/#get_data_config_dirproject_root-pathlibpath-none-none-pathlibpath","title":"<code>get_data_config_dir(project_root: pathlib.Path | None = None) -&gt; pathlib.Path</code>","text":"<p>Return the standard data-config folder path for the repo.</p> <p>Args:     project_root (Path | None): Optionally provide the repo root.</p> <p>Returns:     Path: Full path to /data-config."},{"location":"api/fs_utils/#get_mkdocs_pathspolicy-dict-project_root-pathlibpath-tuplepathlibpath-pathlibpath","title":"<code>get_mkdocs_paths(policy: dict, project_root: pathlib.Path) -&gt; tuple[pathlib.Path, pathlib.Path]</code>","text":"<p>Return paths to mkdocs.yml and the mkdocs source folder based on policy.</p> <p>Args:     policy (dict): Loaded project policy.     project_root (Path): Root of the repo.</p> <p>Returns:     Tuple[Path, Path]: (mkdocs_config_file_path, mkdocs_src_path)</p>"},{"location":"api/fs_utils/#get_org_nameproject_root-pathlibpath-str-none","title":"<code>get_org_name(project_root: pathlib.Path) -&gt; str | None</code>","text":"<p>Return the organization folder name, assuming the repo path follows /path/to// convention. <p>Args:     project_root (Path): The project root path.</p> <p>Returns:     Optional[str]: Organization name, or None if not found.</p>"},{"location":"api/fs_utils/#get_project_rootstart_path-pathlibpath-none-none-pathlibpath","title":"<code>get_project_root(start_path: pathlib.Path | None = None) -&gt; pathlib.Path</code>","text":"<p>Return the root of the repo based on common markers.</p> <p>Searches for markers like .git or pyproject.toml in the current directory and its parents.</p> <p>Args:     start_path (Optional[Path]): Directory to start search from. Defaults to cwd.</p> <p>Returns:     Path: Project root directory.</p> <p>Raises:     RuntimeError: If project root cannot be found based on the markers.</p>"},{"location":"api/fs_utils/#get_repo_package_namesroot_path-pathlibpath-none-none-liststr","title":"<code>get_repo_package_names(root_path: pathlib.Path | None = None) -&gt; list[str]</code>","text":"<p>Return a list of all top-level Python packages in the project.</p> <p>Args:     root_path (Optional[Path]): Optionally specify repo root. Defaults to auto-detection.</p> <p>Returns:     list[str]: List of package names (e.g. 'civic_lib_core', 'civic_dev').</p>"},{"location":"api/fs_utils/#get_runtime_config_pathproject_root-pathlibpath-none-none-pathlibpath","title":"<code>get_runtime_config_path(project_root: pathlib.Path | None = None) -&gt; pathlib.Path</code>","text":"<p>Return the path to runtime_config.yaml under the project root.</p> <p>Args:     project_root (Path | None): Optionally provide the repo root.</p> <p>Returns:     Path: Full path to /runtime_config.yaml."},{"location":"api/fs_utils/#get_source_dirroot_dir-pathlibpath-pathlibpath-none","title":"<code>get_source_dir(root_dir: pathlib.Path) -&gt; pathlib.Path | None</code>","text":"<p>Return the source directory containing Python packages under src/.</p> <p>Args:     root_dir (Path): Project root directory</p> <p>Returns:     Optional[Path]: The source directory if found, otherwise None.</p>"},{"location":"api/fs_utils/#get_valid_packagessrc_dir-pathlibpath-listpathlibpath","title":"<code>get_valid_packages(src_dir: pathlib.Path) -&gt; list[pathlib.Path]</code>","text":"<p>Return all top-level valid Python packages in the given directory.</p> <p>Args:     src_dir (Path): Directory to search for packages.</p> <p>Returns:     list[Path]: List of package directory paths.</p> <p>Raises:     FileNotFoundError: If src_dir doesn't exist.     ValueError: If no valid packages are found.</p>"},{"location":"api/fs_utils/#load_project_policyproject_root-pathlibpath-none-none-dict","title":"<code>load_project_policy(project_root: pathlib.Path | None = None) -&gt; dict</code>","text":"<p>Load Civic Interconnect project policy, allowing client repos to optionally override default settings via a custom policy file.</p> <p>The default policy is loaded from the library's internal <code>project_policy.yaml</code>. If <code>project_root</code> is provided and a <code>project_policy.yaml</code> exists within it, this custom policy will be loaded and its values will be recursively merged into the default policy, overriding any conflicting keys.</p> <p>Args:     project_root (Path | None): If provided, looks for <code>project_policy.yaml</code>                                  in this root directory to apply custom overrides.</p> <p>Returns:     dict: The combined policy data, with custom settings merged over defaults.</p>"},{"location":"api/fs_utils/#resolve_pathrelative_path-str-pathlibpath-pathlibpath","title":"<code>resolve_path(relative_path: str | pathlib.Path) -&gt; pathlib.Path</code>","text":"<p>Resolve a relative path from the repo root.</p> <p>Args:     relative_path (str | Path): Path to resolve.</p> <p>Returns:     Path: Absolute path resolved from project root.</p>"},{"location":"api/fs_utils/#safe_filenamename-str-max_length-int-255-str","title":"<code>safe_filename(name: str, max_length: int = 255) -&gt; str</code>","text":"<p>Convert a string into a safe, filesystem-compatible filename.</p> <p>Args:     name (str): Original string.     max_length (int): Maximum filename length.</p> <p>Returns:     str: Sanitized filename.</p>"},{"location":"api/graphql_utils/","title":"Module <code>graphql_utils</code>","text":""},{"location":"api/graphql_utils/#classes","title":"Classes","text":""},{"location":"api/graphql_utils/#aiohttptransportself-url-str-headers-unionmappingstr-str-mappingmultidict_multidictistr-str-multidict_multidictcimultidict-multidict_multidictcimultidictproxy-iterabletupleunionstr-multidict_multidictistr-str-nonetype-none-cookies-unionmappingstr-unionstr-forwardrefbasecookiestr-forwardrefmorselany-iterabletuplestr-unionstr-forwardrefbasecookiestr-forwardrefmorselany-forwardrefbasecookiestr-nonetype-none-auth-unionaiohttphelpersbasicauth-forwardrefappsyncauthentication-nonetype-none-ssl-unionsslsslcontext-bool-aiohttpclient_reqrepfingerprint-str-ssl_warning-timeout-optionalint-none-ssl_close_timeout-unionint-float-nonetype-10-json_serialize-callable-function-dumps-at-0x00000238f5921440-client_session_args-optionaldictstr-any-none-none","title":"<code>AIOHTTPTransport(self, url: str, headers: Union[Mapping[str, str], Mapping[multidict._multidict.istr, str], multidict._multidict.CIMultiDict, multidict._multidict.CIMultiDictProxy, Iterable[Tuple[Union[str, multidict._multidict.istr], str]], NoneType] = None, cookies: Union[Mapping[str, Union[str, ForwardRef('BaseCookie[str]'), ForwardRef('Morsel[Any]')]], Iterable[Tuple[str, Union[str, ForwardRef('BaseCookie[str]'), ForwardRef('Morsel[Any]')]]], ForwardRef('BaseCookie[str]'), NoneType] = None, auth: Union[aiohttp.helpers.BasicAuth, ForwardRef('AppSyncAuthentication'), NoneType] = None, ssl: Union[ssl.SSLContext, bool, aiohttp.client_reqrep.Fingerprint, str] = 'ssl_warning', timeout: Optional[int] = None, ssl_close_timeout: Union[int, float, NoneType] = 10, json_serialize: Callable = &lt;function dumps at 0x00000238F5921440&gt;, client_session_args: Optional[Dict[str, Any]] = None) -&gt; None</code>","text":"<p>:ref:<code>Async Transport &lt;async_transports&gt;</code> to execute GraphQL queries on remote servers with an HTTP connection.</p> <p>This transport use the aiohttp library with asyncio.</p>"},{"location":"api/graphql_utils/#anyself-args-kwargs","title":"<code>Any(self, /, *args, **kwargs)</code>","text":"<p>Special type indicating an unconstrained type.</p> <ul> <li>Any is compatible with every type.</li> <li>Any assumed to have all methods.</li> <li>All values assumed to be instances of Any.</li> </ul> <p>Note that all the above statements are true from the point of view of static type checkers. At runtime, Any should not be used with instance checks.</p>"},{"location":"api/graphql_utils/#clientself-schema-unionstr-graphqltypeschemagraphqlschema-nonetype-none-introspection-optionalgraphqlutilitiesget_introspection_queryintrospectionquery-none-transport-uniongqltransporttransporttransport-gqltransportasync_transportasynctransport-nonetype-none-fetch_schema_from_transport-bool-false-introspection_args-optionaldict-none-execute_timeout-unionint-float-nonetype-10-serialize_variables-bool-false-parse_results-bool-false-batch_interval-float-0-batch_max-int-10","title":"<code>Client(self, schema: Union[str, graphql.type.schema.GraphQLSchema, NoneType] = None, introspection: Optional[graphql.utilities.get_introspection_query.IntrospectionQuery] = None, transport: Union[gql.transport.transport.Transport, gql.transport.async_transport.AsyncTransport, NoneType] = None, fetch_schema_from_transport: bool = False, introspection_args: Optional[Dict] = None, execute_timeout: Union[int, float, NoneType] = 10, serialize_variables: bool = False, parse_results: bool = False, batch_interval: float = 0, batch_max: int = 10)</code>","text":"<p>The Client class is the main entrypoint to execute GraphQL requests on a GQL transport.</p> <p>It can take sync or async transports as argument and can either execute and subscribe to requests itself with the :func:<code>execute &lt;gql.client.Client.execute&gt;</code> and :func:<code>subscribe &lt;gql.client.Client.subscribe&gt;</code> methods OR can be used to get a sync or async session depending on the transport type.</p> <p>To connect to an :ref:<code>async transport &lt;async_transports&gt;</code> and get an :class:<code>async session &lt;gql.client.AsyncClientSession&gt;</code>, use :code:<code>async with client as session:</code></p> <p>To connect to a :ref:<code>sync transport &lt;sync_transports&gt;</code> and get a :class:<code>sync session &lt;gql.client.SyncClientSession&gt;</code>, use :code:<code>with client as session:</code></p>"},{"location":"api/graphql_utils/#transportprotocolerrorself-args-kwargs","title":"<code>TransportProtocolError(self, /, *args, **kwargs)</code>","text":"<p>Transport protocol error.</p> <p>The answer received from the server does not correspond to the transport protocol.</p>"},{"location":"api/graphql_utils/#transportqueryerrorself-msg-str-query_id-optionalint-none-errors-optionallistany-none-data-optionalany-none-extensions-optionalany-none","title":"<code>TransportQueryError(self, msg: str, query_id: Optional[int] = None, errors: Optional[List[Any]] = None, data: Optional[Any] = None, extensions: Optional[Any] = None)</code>","text":"<p>The server returned an error for a specific query.</p> <p>This exception should not close the transport connection.</p>"},{"location":"api/graphql_utils/#transportservererrorself-message-str-code-optionalint-none","title":"<code>TransportServerError(self, message: str, code: Optional[int] = None)</code>","text":"<p>The server returned a global error.</p> <p>This exception will close the transport connection.</p>"},{"location":"api/graphql_utils/#functions","title":"Functions","text":""},{"location":"api/graphql_utils/#async_paged_queryurl-str-api_key-str-query-any-data_path-liststr-page_info_path-liststr-none-none-listtypingany","title":"<code>async_paged_query(url: str, api_key: str, query: Any, data_path: list[str], page_info_path: list[str] | None = None) -&gt; list[typing.Any]</code>","text":"<p>Asynchronously fetch paginated GraphQL results.</p> <p>Args:     url (str): GraphQL endpoint URL.     api_key (str): Authorization token.     query (gql.Query): Query object.     data_path (list[str]): Path to the list of data edges.     page_info_path (list[str] | None): Optional explicit path to pageInfo.</p> <p>Returns:     list: Combined list of items from all pages.</p>"},{"location":"api/graphql_utils/#fetch_paginatedclient-any-query-any-data_key-str-variables-dict-none-none-listdict","title":"<code>fetch_paginated(client: Any, query: Any, data_key: str, variables: dict | None = None) -&gt; list[dict]</code>","text":"<p>Fetch all pages of a paginated GraphQL query.</p> <p>Args:     client (gql.Client): Initialized GraphQL client.     query (gql.Query): Query object.     data_key (str): Key containing the paginated data.     variables (dict | None): Optional base query variables.</p> <p>Returns:     list[dict]: Combined list of node dicts from all pages.</p>"},{"location":"api/graphql_utils/#handle_transport_errorse-exception-resource_name-str-resource-str","title":"<code>handle_transport_errors(e: Exception, resource_name: str = 'resource') -&gt; str</code>","text":"<p>Handle GraphQL transport errors with consistent logging and user-friendly feedback.</p> <p>Args:     e (Exception): The exception raised by gql transport.     resource_name (str): Human-readable name of the queried resource.</p> <p>Returns:     str: Friendly message if known error (e.g., access not granted).</p> <p>Raises:     Exception: Original exception for unhandled errors.</p>"},{"location":"api/graphql_utils/#paged_queryurl-str-api_key-str-query-any-data_path-liststr-listtypingany","title":"<code>paged_query(url: str, api_key: str, query: Any, data_path: list[str]) -&gt; list[typing.Any]</code>","text":"<p>Run a paged GraphQL query synchronously.</p> <p>Args:     url (str): GraphQL endpoint URL.     api_key (str): Authorization token.     query (gql.Query): Query object.     data_path (list[str]): Path to the list of data edges.</p> <p>Returns:     list: Combined results from all pages.</p> <p>Raises:     Exception: Any error raised by async_paged_query.</p>"},{"location":"api/install_deps/","title":"Module <code>install_deps</code>","text":""},{"location":"api/install_deps/#classes","title":"Classes","text":""},{"location":"api/install_deps/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/install_deps/#functions","title":"Functions","text":""},{"location":"api/install_deps/#get_python_bin","title":"<code>get_python_bin()</code>","text":"<p>Return the path to the Python binary in the virtual environment.</p>"},{"location":"api/install_deps/#get_venv_dir","title":"<code>get_venv_dir()</code>","text":"<p>Return the absolute path to the .venv directory.</p>"},{"location":"api/install_deps/#install_dependenciespython_bin-pathlibpath-is_editable-bool-false","title":"<code>install_dependencies(python_bin: pathlib.Path, is_editable: bool = False)</code>","text":"<p>Install pip tools, project dependencies, and pre-commit hooks.</p>"},{"location":"api/install_deps/#mainis_editable-bool-false-int","title":"<code>main(is_editable: bool = False) -&gt; int</code>","text":"<p>No description available.</p>"},{"location":"api/install_deps/#runcmd-shellfalse","title":"<code>run(cmd, shell=False)</code>","text":"<p>No description available.</p>"},{"location":"api/install_deps/#verify_venv","title":"<code>verify_venv()</code>","text":"<p>Ensure .venv exists and contains a Python binary.</p>"},{"location":"api/layout/","title":"Module <code>layout</code>","text":""},{"location":"api/layout/#functions","title":"Functions","text":""},{"location":"api/layout/#main-none","title":"<code>main() -&gt; None</code>","text":"<p>Discover and print the project layout.</p>"},{"location":"api/log_utils/","title":"Module <code>log_utils</code>","text":""},{"location":"api/log_utils/#classes","title":"Classes","text":""},{"location":"api/log_utils/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/log_utils/#functions","title":"Functions","text":""},{"location":"api/log_utils/#init_loggerlog_level-str-none-none-log_to_console-bool-true-none","title":"<code>init_logger(log_level: str | None = None, log_to_console: bool = True) -&gt; None</code>","text":"<p>Initialize Loguru logging once per session.</p> <p>Automatically loads logging config from project_policy.yaml if available. Defaults to INFO and logs/{date}.log if not found.</p> <p>Args:     log_level (str | None): Optional log level override.     log_to_console (bool): Whether to also log to stderr.</p> <p>Example:     from civic_lib_core import log_utils     log_utils.init_logger(\"INFO\")</p>"},{"location":"api/log_utils/#log_agent_endagent_name-str-status-str-success-none","title":"<code>log_agent_end(agent_name: str, status: str = 'success') -&gt; None</code>","text":"<p>Log the end of an agent with its status and UTC timestamp.</p> <p>Args:     agent_name (str): Name of the agent.     status (str): e.g. \"success\" or \"error\".</p>"},{"location":"api/log_utils/#log_agent_startagent_name-str-none","title":"<code>log_agent_start(agent_name: str) -&gt; None</code>","text":"<p>Log the start of an agent by name.</p> <p>Args:     agent_name (str): Name of the agent.</p>"},{"location":"api/log_utils/#now_utc_strfmt-str-y-m-d-hms-utc-str","title":"<code>now_utc_str(fmt: str = '%Y-%m-%d %H:%M:%S UTC') -&gt; str</code>","text":"<p>Return the current time in UTC as a formatted string.</p> <p>Args:     fmt (str): Format string for datetime output. Default includes 'UTC'.</p> <p>Returns:     str: Formatted current UTC time.</p>"},{"location":"api/prep_code/","title":"Module <code>prep_code</code>","text":""},{"location":"api/prep_code/#classes","title":"Classes","text":""},{"location":"api/prep_code/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/prep_code/#functions","title":"Functions","text":""},{"location":"api/prep_code/#get_lib_version-str","title":"<code>get_lib_version() -&gt; str</code>","text":"<p>Get the current library version.</p> <p>Returns:     str: The semantic version string (e.g., \"1.2.3\").</p>"},{"location":"api/prep_code/#main-int","title":"<code>main() -&gt; int</code>","text":"<p>No description available.</p>"},{"location":"api/prep_code/#run_checkcommand-liststr-label-str-none","title":"<code>run_check(command: list[str], label: str) -&gt; None</code>","text":"<p>Run a shell command and fail fast if it errors.</p>"},{"location":"api/prep_code/#should_reinstall-bool","title":"<code>should_reinstall() -&gt; bool</code>","text":"<p>Determine whether the virtual environment should be reinstalled based on timestamps of dependency files.</p>"},{"location":"api/project_checks/","title":"Module <code>project_checks</code>","text":""},{"location":"api/project_checks/#classes","title":"Classes","text":""},{"location":"api/project_checks/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/project_checks/#functions","title":"Functions","text":""},{"location":"api/project_checks/#check_empty_dirsproject_root-pathlibpath-liststr","title":"<code>check_empty_dirs(project_root: pathlib.Path) -&gt; list[str]</code>","text":"<p>No description available.</p>"},{"location":"api/project_checks/#check_mkdocs_consistencyproject_root-pathlibpath-policy-dict-liststr","title":"<code>check_mkdocs_consistency(project_root: pathlib.Path, policy: dict) -&gt; list[str]</code>","text":"<p>No description available.</p>"},{"location":"api/project_checks/#check_oversized_py_filesproject_root-pathlibpath-src_dir-pathlibpath-policy-dict-liststr","title":"<code>check_oversized_py_files(project_root: pathlib.Path, src_dir: pathlib.Path, policy: dict) -&gt; list[str]</code>","text":"<p>No description available.</p>"},{"location":"api/project_checks/#check_py_files_outside_srcproject_root-pathlibpath-src_dir-pathlibpath-liststr","title":"<code>check_py_files_outside_src(project_root: pathlib.Path, src_dir: pathlib.Path) -&gt; list[str]</code>","text":"<p>No description available.</p>"},{"location":"api/project_checks/#check_python_project_dirsproject_root-pathlibpath-policy-dict-liststr","title":"<code>check_python_project_dirs(project_root: pathlib.Path, policy: dict) -&gt; list[str]</code>","text":"<p>No description available.</p>"},{"location":"api/project_checks/#check_python_project_filesproject_root-pathlibpath-policy-dict-liststr","title":"<code>check_python_project_files(project_root: pathlib.Path, policy: dict) -&gt; list[str]</code>","text":"<p>No description available.</p>"},{"location":"api/project_checks/#check_required_filesproject_root-pathlibpath-policy-dict-liststr","title":"<code>check_required_files(project_root: pathlib.Path, policy: dict) -&gt; list[str]</code>","text":"<p>No description available.</p>"},{"location":"api/project_checks/#main-none","title":"<code>main() -&gt; None</code>","text":"<p>Main entry point to run all checks and print results.</p>"},{"location":"api/project_checks/#run_all_checks-liststr-none","title":"<code>run_all_checks() -&gt; list[str] | None</code>","text":"<p>Run all project-level checks and return a list of issues.</p> <p>Returns:     list[str]: Descriptions of issues found.</p>"},{"location":"api/project_layout/","title":"Module <code>project_layout</code>","text":""},{"location":"api/project_layout/#classes","title":"Classes","text":""},{"location":"api/project_layout/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/project_layout/#projectlayoutself-args-kwargs","title":"<code>ProjectLayout(self, /, *args, **kwargs)</code>","text":"<p>Represents the layout of a project, including key directories and metadata.</p> <p>Attributes:     project_root (Path): The root directory of the project.     src_dir (Path | None): The source directory containing the main code, or None if not applicable.     packages (list[Path]): A list of paths to package directories within the project.     api_markdown_src_dir (Path): The directory containing API documentation source Markdown files                                   (e.g., project_root/mkdocs_src/api).     org_name (str | None): The name of the organization, or None if not specified.     policy (dict): A dictionary containing project policy information.</p>"},{"location":"api/project_layout/#functions","title":"Functions","text":""},{"location":"api/project_layout/#namedtupletypename-fieldsnone-kwargs","title":"<code>NamedTuple(typename, fields=None, /, **kwargs)</code>","text":"<p>Typed version of namedtuple.</p> <p>Usage::</p> <pre><code>class Employee(NamedTuple):\n    name: str\n    id: int\n</code></pre> <p>This is equivalent to::</p> <pre><code>Employee = collections.namedtuple('Employee', ['name', 'id'])\n</code></pre> <p>The resulting class has an extra annotations attribute, giving a dict that maps field names to types.  (The field names are also in the _fields attribute, which is part of the namedtuple API.) An alternative equivalent functional syntax is also accepted::</p> <pre><code>Employee = NamedTuple('Employee', [('name', str), ('id', int)])\n</code></pre>"},{"location":"api/project_layout/#discover_project_layout-project_layoutprojectlayout","title":"<code>discover_project_layout() -&gt; project_layout.ProjectLayout</code>","text":"<p>Return key layout paths for the current Civic Interconnect project.</p> <p>This function delegates the primary discovery to <code>fs_utils.discover_project_layout()</code> which is responsible for finding all necessary paths and loading the policy, then returns the structured ProjectLayout object.</p> <p>Returns:     ProjectLayout: Structured layout information.</p>"},{"location":"api/project_layout/#format_layoutlayout-project_layoutprojectlayout-str","title":"<code>format_layout(layout: project_layout.ProjectLayout) -&gt; str</code>","text":"<p>Format layout info for display.</p> <p>Args:     layout (ProjectLayout): The layout info to print.</p> <p>Returns:     str: A formatted string for display.</p>"},{"location":"api/project_layout/#get_errorslayout-errors","title":"<code>get_errors(layout, errors)</code>","text":"<p>No description available.</p>"},{"location":"api/project_layout/#main-none","title":"<code>main() -&gt; None</code>","text":"<p>Standalone entry point for testing this layout module. Prints layout and any issues found.</p>"},{"location":"api/project_layout/#verify_layoutlayout-project_layoutprojectlayout-liststr","title":"<code>verify_layout(layout: project_layout.ProjectLayout) -&gt; list[str]</code>","text":"<p>Verify layout assumptions for a Civic Interconnect repo.</p> <p>Args:     layout (ProjectLayout): The discovered layout.</p> <p>Returns:     list[str]: Any problems detected (empty list means all OK).</p>"},{"location":"api/project_policy/","title":"Module <code>project_policy</code>","text":""},{"location":"api/project_policy/#classes","title":"Classes","text":""},{"location":"api/project_policy/#anyself-args-kwargs","title":"<code>Any(self, /, *args, **kwargs)</code>","text":"<p>Special type indicating an unconstrained type.</p> <ul> <li>Any is compatible with every type.</li> <li>Any assumed to have all methods.</li> <li>All values assumed to be instances of Any.</li> </ul> <p>Note that all the above statements are true from the point of view of static type checkers. At runtime, Any should not be used with instance checks.</p>"},{"location":"api/project_policy/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/project_policy/#functions","title":"Functions","text":""},{"location":"api/project_policy/#load_project_policyproject_root-pathlibpath-none-none-dict","title":"<code>load_project_policy(project_root: pathlib.Path | None = None) -&gt; dict</code>","text":"<p>Load Civic Interconnect project policy, allowing client repos to optionally override default settings via a custom policy file.</p> <p>The default policy is loaded from the library's internal <code>project_policy.yaml</code>. If <code>project_root</code> is provided and a <code>project_policy.yaml</code> exists within it, this custom policy will be loaded and its values will be recursively merged into the default policy, overriding any conflicting keys.</p> <p>Args:     project_root (Path | None): If provided, looks for <code>project_policy.yaml</code>                                  in this root directory to apply custom overrides.</p> <p>Returns:     dict: The combined policy data, with custom settings merged over defaults.</p>"},{"location":"api/publish_api/","title":"Module <code>publish_api</code>","text":""},{"location":"api/publish_api/#functions","title":"Functions","text":""},{"location":"api/publish_api/#main-int","title":"<code>main() -&gt; int</code>","text":"<p>Regenerate summary and reference API documentation for all packages in src/. The generated Markdown and YAML files are placed into the MkDocs source directory (typically <code>mkdocs_src/api/</code>).</p> <p>Returns:     int: exit code (0 if successful, nonzero otherwise)</p>"},{"location":"api/query_utils/","title":"Module <code>query_utils</code>","text":""},{"location":"api/query_utils/#functions","title":"Functions","text":""},{"location":"api/query_utils/#fetch_paginatedclient-any-query-any-data_key-str-variables-dict-none-none-listdict","title":"<code>fetch_paginated(client: Any, query: Any, data_key: str, variables: dict | None = None) -&gt; list[dict]</code>","text":"<p>Fetch all pages of a paginated GraphQL query.</p> <p>Args:     client (gql.Client): Initialized GraphQL client.     query (gql.Query): Query object.     data_key (str): Key containing the paginated data.     variables (dict | None): Optional base query variables.</p> <p>Returns:     list[dict]: Combined list of node dicts from all pages.</p>"},{"location":"api/release/","title":"Module <code>release</code>","text":""},{"location":"api/release/#classes","title":"Classes","text":""},{"location":"api/release/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/release/#functions","title":"Functions","text":""},{"location":"api/release/#main-int","title":"<code>main() -&gt; int</code>","text":"<p>Complete the release workflow for the current version.</p>"},{"location":"api/release/#publish_api_docs-none","title":"<code>publish_api_docs() -&gt; None</code>","text":"<p>One-liner to generate complete API documentation for release.</p> <ul> <li>Discovers all Python packages in src/.</li> <li>Generates Markdown &amp; YAML docs for each into mkdocs_src/api.</li> <li>Writes mkdocs.yml to repo root.</li> <li>Writes index.md to mkdocs_src.</li> </ul>"},{"location":"api/release/#runcmd-str-check-bool-true-none","title":"<code>run(cmd: str, check: bool = True) -&gt; None</code>","text":"<p>Run a shell command and log it.</p>"},{"location":"api/report_archiver/","title":"Module <code>report_archiver</code>","text":""},{"location":"api/report_archiver/#classes","title":"Classes","text":""},{"location":"api/report_archiver/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/report_archiver/#datetimeself-args-kwargs","title":"<code>datetime(self, /, *args, **kwargs)</code>","text":"<p>datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])</p> <p>The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints.</p>"},{"location":"api/report_archiver/#timedeltaself-args-kwargs","title":"<code>timedelta(self, /, *args, **kwargs)</code>","text":"<p>Difference between two datetime values.</p> <p>timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)</p> <p>All arguments are optional and default to 0. Arguments may be integers or floats, and may be positive or negative.</p>"},{"location":"api/report_archiver/#functions","title":"Functions","text":""},{"location":"api/report_archiver/#archive_old_reportsagent_dir-pathlibpath-keep_latest-bool-true-listpathlibpath","title":"<code>archive_old_reports(agent_dir: pathlib.Path, keep_latest: bool = True) -&gt; list[pathlib.Path]</code>","text":"<p>Rename old .json reports to .archived.json, optionally keeping the latest.</p> <p>Args:     agent_dir (Path): Directory with report files.     keep_latest (bool): Whether to keep the most recent report unarchived.</p> <p>Returns:     list[Path]: List of archived report file paths.</p>"},{"location":"api/report_archiver/#archive_reports_older_thanagent_dir-pathlibpath-days_old-int-listpathlibpath","title":"<code>archive_reports_older_than(agent_dir: pathlib.Path, days_old: int) -&gt; list[pathlib.Path]</code>","text":"<p>Archive reports older than a specified number of days.</p>"},{"location":"api/report_constants/","title":"Module <code>report_constants</code>","text":""},{"location":"api/report_constants/#classes","title":"Classes","text":""},{"location":"api/report_constants/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/report_formatter/","title":"Module <code>report_formatter</code>","text":""},{"location":"api/report_formatter/#classes","title":"Classes","text":""},{"location":"api/report_formatter/#anyself-args-kwargs","title":"<code>Any(self, /, *args, **kwargs)</code>","text":"<p>Special type indicating an unconstrained type.</p> <ul> <li>Any is compatible with every type.</li> <li>Any assumed to have all methods.</li> <li>All values assumed to be instances of Any.</li> </ul> <p>Note that all the above statements are true from the point of view of static type checkers. At runtime, Any should not be used with instance checks.</p>"},{"location":"api/report_formatter/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/report_formatter/#functions","title":"Functions","text":""},{"location":"api/report_formatter/#format_report_as_csvreport-dict-str","title":"<code>format_report_as_csv(report: dict) -&gt; str</code>","text":"<p>Convert report results to CSV format.</p> <p>Args:     report (dict): Parsed report dictionary.</p> <p>Returns:     str: CSV-formatted string of the report results.</p>"},{"location":"api/report_formatter/#format_report_as_markdownreport-dict-str","title":"<code>format_report_as_markdown(report: dict) -&gt; str</code>","text":"<p>Convert a report dictionary to a Markdown summary string.</p> <p>Args:     report (dict): Parsed report dictionary.</p> <p>Returns:     str: Markdown-formatted report summary.</p>"},{"location":"api/report_formatter/#format_report_as_textreport-dict-str","title":"<code>format_report_as_text(report: dict) -&gt; str</code>","text":"<p>Convert a report dictionary to a plain text summary string.</p> <p>Args:     report (dict): Parsed report dictionary.</p> <p>Returns:     str: Text-formatted report summary.</p>"},{"location":"api/report_formatter/#to_csvdata-listdictstr-typingany-path-pathlibpath-none","title":"<code>to_csv(data: list[dict[str, typing.Any]], path: pathlib.Path) -&gt; None</code>","text":"<p>Write raw result data to a CSV file.</p> <p>Args:     data (list[dict]): Result rows to write.     path (Path): File path to write CSV to.</p>"},{"location":"api/report_formatter/#to_markdowndata-listdictstr-typingany-path-pathlibpath-none","title":"<code>to_markdown(data: list[dict[str, typing.Any]], path: pathlib.Path) -&gt; None</code>","text":"<p>Write raw result data to a Markdown table.</p> <p>Args:     data (list[dict]): Result rows to write.     path (Path): File path to write Markdown to.</p>"},{"location":"api/report_indexer/","title":"Module <code>report_indexer</code>","text":""},{"location":"api/report_indexer/#classes","title":"Classes","text":""},{"location":"api/report_indexer/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/report_indexer/#functions","title":"Functions","text":""},{"location":"api/report_indexer/#ensure_dirpath-str-pathlibpath-pathlibpath","title":"<code>ensure_dir(path: str | pathlib.Path) -&gt; pathlib.Path</code>","text":"<p>Ensure a directory exists, creating it if necessary.</p> <p>Args:     path (str | Path): The directory path to ensure.</p> <p>Returns:     Path: The resolved Path object of the directory.</p> <p>Raises:     OSError: If directory cannot be created.</p>"},{"location":"api/report_indexer/#generate_indexreport_dir-pathlibpath-windowspathreports-none","title":"<code>generate_index(report_dir: pathlib.Path = WindowsPath('reports')) -&gt; None</code>","text":"<p>Generate a Markdown index listing the latest report from each agent.</p> <p>Args:     report_dir (Path): The base <code>reports/</code> directory to scan.</p>"},{"location":"api/report_indexer/#get_agent_name_from_pathpath-pathlibpath-str","title":"<code>get_agent_name_from_path(path: pathlib.Path) -&gt; str</code>","text":"<p>Extract and format the agent name from a report file path.</p> <p>The agent name is derived from the parent folder of the report file, with underscores replaced by spaces and title-cased.</p> <p>If the path does not have a parent directory, returns 'Unknown Agent'.</p> <p>Args:     path (Path): The path to a report file.</p> <p>Returns:     str: Formatted agent name or fallback string.</p>"},{"location":"api/report_indexer/#get_latest_reportagent_dir-pathlibpath-pathlibpath-none","title":"<code>get_latest_report(agent_dir: pathlib.Path) -&gt; pathlib.Path | None</code>","text":"<p>Get the most recent report file from the specified agent directory.</p> <p>Args:     agent_dir (Path): Path to the agent's report folder.</p> <p>Returns:     Path | None: The latest report file, or None if none found.</p>"},{"location":"api/report_reader/","title":"Module <code>report_reader</code>","text":""},{"location":"api/report_reader/#classes","title":"Classes","text":""},{"location":"api/report_reader/#anyself-args-kwargs","title":"<code>Any(self, /, *args, **kwargs)</code>","text":"<p>Special type indicating an unconstrained type.</p> <ul> <li>Any is compatible with every type.</li> <li>Any assumed to have all methods.</li> <li>All values assumed to be instances of Any.</li> </ul> <p>Note that all the above statements are true from the point of view of static type checkers. At runtime, Any should not be used with instance checks.</p>"},{"location":"api/report_reader/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/report_reader/#functions","title":"Functions","text":""},{"location":"api/report_reader/#check_schema_versionreport-dictstr-typingany-required-str-strict-bool-false-bool","title":"<code>check_schema_version(report: dict[str, typing.Any], required: str, strict: bool = False) -&gt; bool</code>","text":"<p>Check if the report's schema version matches the required version. Args:     report (dict): The parsed report dictionary.     required (str): The required schema version to check against.     strict (bool): If True, raise an error if the version does not match.                    If False, return False and log a warning. Returns:     bool: True if the schema version matches, False otherwise.</p>"},{"location":"api/report_reader/#check_versionagent_version-str-lib_version-str-strict-bool-false-bool","title":"<code>check_version(agent_version: str, lib_version: str, strict: bool = False) -&gt; bool</code>","text":"<p>Check compatibility of agent and lib versions using SemVer rules.</p> <p>Args:     agent_version (str): Version string for the agent.     lib_version (str): Version string for the shared library.     strict (bool): If True, requires exact version match.</p> <p>Returns:     bool: True if compatible, False otherwise.</p>"},{"location":"api/report_reader/#get_latest_reportagent_dir-pathlibpath-pathlibpath-none","title":"<code>get_latest_report(agent_dir: pathlib.Path) -&gt; pathlib.Path | None</code>","text":"<p>Get the most recent report file from the specified agent directory.</p> <p>Args:     agent_dir (Path): Path to the agent's report folder.</p> <p>Returns:     Path | None: The latest report file, or None if none found.</p>"},{"location":"api/report_reader/#is_report_filepath-pathlibpath-bool","title":"<code>is_report_file(path: pathlib.Path) -&gt; bool</code>","text":"<p>Determine whether the given file path is a valid report file.</p> <p>A valid report file must: - Have a \".json\" extension - Begin with a date prefix (e.g., \"2024-01-01\")</p> <p>Args:     path (Path): The path to check.</p> <p>Returns:     bool: True if the path matches report file format, False otherwise.</p>"},{"location":"api/report_reader/#read_latest_reportagent_dir-pathlibpath-strict-bool-false-dict-none","title":"<code>read_latest_report(agent_dir: pathlib.Path, strict: bool = False) -&gt; dict | None</code>","text":"<p>Read and return the contents of the latest report for a given agent.</p> <p>Args:     agent_dir (Path): Path to the agent's report folder.     strict (bool): If True, raise errors on missing or invalid reports.                    If False, return None and log a warning.</p> <p>Returns:     dict | None: Parsed report contents, or None if no report exists or format is invalid (in non-strict mode).</p>"},{"location":"api/report_reader/#validate_report_formatreport-dict-bool","title":"<code>validate_report_format(report: dict) -&gt; bool</code>","text":"<p>Validate that a report contains all expected top-level keys.</p> <p>Args:     report (dict): The parsed report to validate.</p> <p>Returns:     bool: True if valid, False otherwise.</p>"},{"location":"api/report_summary/","title":"Module <code>report_summary</code>","text":""},{"location":"api/report_summary/#classes","title":"Classes","text":""},{"location":"api/report_summary/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/report_summary/#functions","title":"Functions","text":""},{"location":"api/report_summary/#write_markdown_summaryreport-dict-path-pathlibpath-none","title":"<code>write_markdown_summary(report: dict, path: pathlib.Path) -&gt; None</code>","text":"<p>Write a Markdown summary of a report's key metadata.</p> <p>Args:     report (dict): The report data (already parsed).     path (Path): The output path to write the .md file.</p>"},{"location":"api/report_utils/","title":"Module <code>report_utils</code>","text":""},{"location":"api/report_utils/#classes","title":"Classes","text":""},{"location":"api/report_utils/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/report_utils/#functions","title":"Functions","text":""},{"location":"api/report_utils/#get_agent_name_from_pathpath-pathlibpath-str","title":"<code>get_agent_name_from_path(path: pathlib.Path) -&gt; str</code>","text":"<p>Extract and format the agent name from a report file path.</p> <p>The agent name is derived from the parent folder of the report file, with underscores replaced by spaces and title-cased.</p> <p>If the path does not have a parent directory, returns 'Unknown Agent'.</p> <p>Args:     path (Path): The path to a report file.</p> <p>Returns:     str: Formatted agent name or fallback string.</p>"},{"location":"api/report_utils/#is_report_filepath-pathlibpath-bool","title":"<code>is_report_file(path: pathlib.Path) -&gt; bool</code>","text":"<p>Determine whether the given file path is a valid report file.</p> <p>A valid report file must: - Have a \".json\" extension - Begin with a date prefix (e.g., \"2024-01-01\")</p> <p>Args:     path (Path): The path to check.</p> <p>Returns:     bool: True if the path matches report file format, False otherwise.</p>"},{"location":"api/report_writer/","title":"Module <code>report_writer</code>","text":""},{"location":"api/report_writer/#classes","title":"Classes","text":""},{"location":"api/report_writer/#anyself-args-kwargs","title":"<code>Any(self, /, *args, **kwargs)</code>","text":"<p>Special type indicating an unconstrained type.</p> <ul> <li>Any is compatible with every type.</li> <li>Any assumed to have all methods.</li> <li>All values assumed to be instances of Any.</li> </ul> <p>Note that all the above statements are true from the point of view of static type checkers. At runtime, Any should not be used with instance checks.</p>"},{"location":"api/report_writer/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/report_writer/#datetimeself-args-kwargs","title":"<code>datetime(self, /, *args, **kwargs)</code>","text":"<p>datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])</p> <p>The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be ints.</p>"},{"location":"api/report_writer/#functions","title":"Functions","text":""},{"location":"api/report_writer/#ensure_dirpath-str-pathlibpath-pathlibpath","title":"<code>ensure_dir(path: str | pathlib.Path) -&gt; pathlib.Path</code>","text":"<p>Ensure a directory exists, creating it if necessary.</p> <p>Args:     path (str | Path): The directory path to ensure.</p> <p>Returns:     Path: The resolved Path object of the directory.</p> <p>Raises:     OSError: If directory cannot be created.</p>"},{"location":"api/report_writer/#now_utc_strfmt-str-y-m-d-hms-utc-str","title":"<code>now_utc_str(fmt: str = '%Y-%m-%d %H:%M:%S UTC') -&gt; str</code>","text":"<p>Return the current time in UTC as a formatted string.</p> <p>Args:     fmt (str): Format string for datetime output. Default includes 'UTC'.</p> <p>Returns:     str: Formatted current UTC time.</p>"},{"location":"api/report_writer/#safe_filenamename-str-max_length-int-255-str","title":"<code>safe_filename(name: str, max_length: int = 255) -&gt; str</code>","text":"<p>Convert a string into a safe, filesystem-compatible filename.</p> <p>Args:     name (str): Original string.     max_length (int): Maximum filename length.</p> <p>Returns:     str: Sanitized filename.</p>"},{"location":"api/report_writer/#write_reportdata-listdictstr-typingany-agent_name-str-agent_version-str-schema_version-str-100-report_dir-str-pathlibpath-windowspathreports-file_format-str-json-pathlibpath","title":"<code>write_report(data: list[dict[str, typing.Any]], agent_name: str, agent_version: str, schema_version: str = '1.0.0', report_dir: str | pathlib.Path = WindowsPath('reports'), file_format: str = 'json') -&gt; pathlib.Path</code>","text":"<p>Write agent output to a timestamped report file with metadata.</p> <p>Args:     data (list[dict[str, Any]]): The results to include in the report.     agent_name (str): The name of the agent generating the report.     agent_version (str): The version of the agent code.     report_dir (str | Path): Root directory where reports are saved (default: REPORTS_DIR).     file_format (str): Output format, one of \"json\" or \"csv\" (default: \"json\").</p> <p>Returns:     Path: The full path to the saved report file.</p>"},{"location":"api/schema_utils/","title":"Module <code>schema_utils</code>","text":""},{"location":"api/schema_utils/#classes","title":"Classes","text":""},{"location":"api/schema_utils/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/schema_utils/#functions","title":"Functions","text":""},{"location":"api/schema_utils/#detect_schema_changeold_file-pathlibpath-new_data-dict-bool","title":"<code>detect_schema_change(old_file: pathlib.Path, new_data: dict) -&gt; bool</code>","text":"<p>Detect if the schema has changed by comparing the old file's hash with the new data. Args:     old_file (Path): The path to the old schema file.     new_data (dict): The new schema data to compare against. Returns:     bool: True if the schema has changed (i.e., hashes differ), False otherwise.</p>"},{"location":"api/schema_utils/#hash_dictdata-dict-str","title":"<code>hash_dict(data: dict) -&gt; str</code>","text":"<p>Hash a JSON-serializable dictionary for change detection. Args:     data (dict): The dictionary to hash. Returns:     str: The SHA-256 hash of the JSON-encoded dictionary.</p>"},{"location":"api/schema_utils/#load_jsonpath-str-pathlibpath-dict","title":"<code>load_json(path: str | pathlib.Path) -&gt; dict</code>","text":"<p>Load a JSON file and return its contents as a dictionary. Args:     path (str | Path): The path to the JSON file. Returns:     dict: The parsed JSON data. Raises:     FileNotFoundError: If the file does not exist.     json.JSONDecodeError: If the file is not valid JSON.</p>"},{"location":"api/version_utils/","title":"Module <code>version_utils</code>","text":""},{"location":"api/version_utils/#classes","title":"Classes","text":""},{"location":"api/version_utils/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/version_utils/#functions","title":"Functions","text":""},{"location":"api/version_utils/#bump_versionold_version-str-new_version-str-int","title":"<code>bump_version(old_version: str, new_version: str) -&gt; int</code>","text":"<p>No description available.</p>"},{"location":"api/version_utils/#check_versionagent_version-str-lib_version-str-strict-bool-false-bool","title":"<code>check_version(agent_version: str, lib_version: str, strict: bool = False) -&gt; bool</code>","text":"<p>Check compatibility of agent and lib versions using SemVer rules.</p> <p>Args:     agent_version (str): Version string for the agent.     lib_version (str): Version string for the shared library.     strict (bool): If True, requires exact version match.</p> <p>Returns:     bool: True if compatible, False otherwise.</p>"},{"location":"api/version_utils/#find_init_filesroot_dir-pathlibpath-listpathlibpath","title":"<code>find_init_files(root_dir: pathlib.Path) -&gt; list[pathlib.Path]</code>","text":"<p>Recursively find all init.py files under the given directory.</p>"},{"location":"api/version_utils/#get_lib_version-str","title":"<code>get_lib_version() -&gt; str</code>","text":"<p>Get the current library version.</p> <p>Returns:     str: The semantic version string (e.g., \"1.2.3\").</p>"},{"location":"api/version_utils/#get_version-str","title":"<code>get_version() -&gt; str</code>","text":"<p>Convenience alias for get_lib_version().</p>"},{"location":"api/version_utils/#lib_version-str","title":"<code>lib_version() -&gt; str</code>","text":"<p>Convenience alias for get_lib_version().</p>"},{"location":"api/version_utils/#parse_versionversion-str-tupleint-int-int","title":"<code>parse_version(version: str) -&gt; tuple[int, int, int]</code>","text":"<p>Parse a version string into a tuple of integers.</p> <p>Args:     version (str): A semantic version string, e.g., \"1.2.3\".</p> <p>Returns:     tuple[int, int, int]: A tuple of (major, minor, patch) version numbers.</p> <p>Raises:     ValueError: If the version string is not in the expected format.</p>"},{"location":"api/version_utils/#update_version_in_initpath-pathlibpath-new_version-str-bool","title":"<code>update_version_in_init(path: pathlib.Path, new_version: str) -&gt; bool</code>","text":"<p>Update version assignment in a given init.py file. Only works for simple string assignment: version = \"...\"</p>"},{"location":"api/version_utils/#update_version_stringpath-pathlibpath-old-str-new-str-bool","title":"<code>update_version_string(path: pathlib.Path, old: str, new: str) -&gt; bool</code>","text":"<p>No description available.</p>"},{"location":"api/yaml_utils/","title":"Module <code>yaml_utils</code>","text":""},{"location":"api/yaml_utils/#classes","title":"Classes","text":""},{"location":"api/yaml_utils/#anyself-args-kwargs","title":"<code>Any(self, /, *args, **kwargs)</code>","text":"<p>Special type indicating an unconstrained type.</p> <ul> <li>Any is compatible with every type.</li> <li>Any assumed to have all methods.</li> <li>All values assumed to be instances of Any.</li> </ul> <p>Note that all the above statements are true from the point of view of static type checkers. At runtime, Any should not be used with instance checks.</p>"},{"location":"api/yaml_utils/#pathself-args-kwargs","title":"<code>Path(self, *args, **kwargs)</code>","text":"<p>PurePath subclass that can make system calls.</p> <p>Path represents a filesystem path but unlike PurePath, also offers methods to do system calls on path objects. Depending on your system, instantiating a Path will return either a PosixPath or a WindowsPath object. You can also instantiate a PosixPath or WindowsPath directly, but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>"},{"location":"api/yaml_utils/#functions","title":"Functions","text":""},{"location":"api/yaml_utils/#read_yamlpath-str-pathlibpath-dictstr-typingany","title":"<code>read_yaml(path: str | pathlib.Path) -&gt; dict[str, typing.Any]</code>","text":"<p>Read and parse a YAML file into a dictionary.</p> <p>Args:     path (str | Path): YAML file path.</p> <p>Returns:     dict: Parsed YAML data.</p>"},{"location":"api/yaml_utils/#write_yamldata-dictstr-typingany-path-str-pathlibpath-pathlibpath","title":"<code>write_yaml(data: dict[str, typing.Any], path: str | pathlib.Path) -&gt; pathlib.Path</code>","text":"<p>Write a dictionary to a YAML file.</p> <p>Args:     data (dict): Data to write.     path (str | Path): File path to write to.</p> <p>Returns:     Path: The path the file was written to.</p>"}]}
